
/*
Declare token types at the top of the bison file,
causing them to be automatically generated in parser.tab.h
for use by scanner.c.
*/

%debug
%define parse.error detailed

%token TOKEN_ADD
%token TOKEN_SUB
%token TOKEN_MULT
%token TOKEN_POW
%token TOKEN_NUMBER
%token TOKEN_ERROR
%token TOKEN_PRINT
%token TOKEN_DIV
%token TOKEN_VAR
%token TOKEN_EQUAL
%token TOKEN_MY
%token TOKEN_CLOSE_PARENTHESIS
%token TOKEN_OPEN_PARENTHESIS
%token TOKEN_SEMI
%token TOKEN_STRING
%token TOKEN_SQRT

%union {
  struct stmt *stmt;
  struct expr *expr;
  struct decl *decl;
};

%type <stmt> program statements statement print_statement assignment
%type <expr> expr factor term name string_expr
%type <decl> declaration

%{
#define YYDEBUG 1

#include <math.h>
#include <stdio.h>
#include <stdlib.h>
#include "expr.h"


/*
Clunky: Manually declare the interface to the scanner generated by flex. 
*/

extern int yylineno;
extern char *yytext;
extern int yylex();
extern void yyerror(const char*);

/*
Clunky: Keep the final result of the parse in a global variable,
so that it can be retrieved by main().
*/

struct stmt * parser_result = 0;

%}


%%

program:
    statements { parser_result = $1; return 0; }

statements: /* empty */
    | statement statements { $$ = $1; $1->next = $2; }

statement: print_statement TOKEN_SEMI { $$ = $1; }
    | assignment TOKEN_SEMI { $$ = $1; }

assignment: declaration { $$ = stmt_create(STMT_DECL,$1,0,0,0,0,0,0); }

print_statement: TOKEN_PRINT expr { $$ = stmt_create(STMT_PRINT,0,0,$2,0,0,0,0); }
    | TOKEN_PRINT string_expr { $$ = stmt_create(STMT_PRINT,0,0,$2,0,0,0,0); }
 
string_expr : TOKEN_STRING { $$ = expr_create_string_literal(yytext); }

declaration: TOKEN_MY name TOKEN_EQUAL expr { $$ = decl_create($2,type_create(TYPE_FLOAT,0),$4,0,0); }

name : TOKEN_VAR { $$ = expr_create_name(yytext); }

expr: expr TOKEN_ADD term { $$ = expr_create(EXPR_ADD,$1,$3); }
    | expr TOKEN_SUB term { $$ = expr_create(EXPR_SUBTRACT,$1,$3); }
    | term { $$ = $1; }

term: term TOKEN_MULT factor { $$ = expr_create(EXPR_MULTIPLY,$1,$3); }
    | term TOKEN_DIV factor { $$ = expr_create(EXPR_DIVIDE,$1,$3); }
    | factor { $$ = $1; }
    ;

factor : factor TOKEN_POW factor { $$ = expr_create(EXPR_POW,$1,$3); }
    | TOKEN_OPEN_PARENTHESIS expr TOKEN_CLOSE_PARENTHESIS { $$ = $2; }
    | TOKEN_SUB factor { $$ = expr_create(EXPR_SUBTRACT, expr_create_integer_literal(0),$2); }
    | TOKEN_NUMBER
    { $$ = expr_create_integer_literal(atoi(yytext)); }
    | TOKEN_VAR
    { $$ = expr_create_name(yytext); }

%%

void yyerror(const char* msg) {
    fprintf(stderr, "Error | Line: %d\n%s\n",yylineno,msg);
}